We compare the performance of our MCFS algorithm with MacosVSpan for mining maximal contiguous frequent sub-sequences. In this comparison, we only consider the memory-based approach, as done by most existing works. All programs were written and compiled using Microsoft Visual C++ 6.0, run with Microsoft Windows XP with a Pentium Duel Core 2.13 GHz CPU with 4 GB of main memory and 500 GB hard disk. As for practical DNA sequence databases, 'Human genome' (Homo sapiens GRCh37.64 DNA Chromosome Part 1, 2, 3) and 'Bacteria DNA sequence dataset' were downloaded from the NCBI website (http://www.ncbi.nlm.nih.gov/nuccore/). The human genome database contains 112,000 sequences, with sequence length 60. The bacteria dataset consists of 20,000 sequences, with sequence length 1,040.
As for validating the combined memory-disk based approach, we aim to show only the run-time efficiency. We applied our main memory disk-based mining approach to Homo sapiens GRCh37.64 DNA Chromosome Part 1, 2, and 3. Part 2 has 98,000 sequences and a length of 60, and part 3 has 105,000 sequences with sequence length of 60.
With various values of minimum support, we compared the run-time performance of three approaches: MCFS (our algorithm), MacosVSpan [8], and Latest Approach [9]. Figs. 4 and 5 show the retrieval performance with respect to the change of minimum support, indicating that MCFS outperforms the other two.
We also compared the memory usage of the three approaches with various values of minimum support. The search space was relatively smaller, because we made use of sub-sequence and super-sequence relationships, and whenever reaching to the minimum support threshold, the sub-sequence for contiguous frequent patterns was not searched. Figs. 6 and 7 show the memory usage, indicating that our approach shows relatively low memory usage compared to the other two. Although both MacosVSpan and our MCFS algorithm process one PDB after another and then produce the maximal contiguous frequent patterns by traversing the suffix tree, the size of the PDB cannot be larger than the original database (according to our proposed lemma); hence, the PDBs can be fit in the memory. This is why MCFS consumes much less memory compared to MacosVSpan.
The Latest Approach [9] requires slightly larger memory, because it constructs the spanning tree by processing all of them at once. It does not consider the memory usage while creating and producing the fixed-length spanning tree. Since it first constructs the fixed-length spanning tree and then expands these candidate item sets to generate longer length candidate item sets, it is not guaranteed to be fit in the memory.
Finally, we validate our combined memory disk-based approach by applying it to Homo sapiens GRCh37.64 DNA Chromosome Parts 1, 2, and 3. We assume that Parts 1, 2, and 3 are partitioned and stored on the disk. With various settings of minimum support threshold, we measured the run-time performance (Fig. 8).
In this paper, we have proposed an efficient algorithm, called MCFS, for mining maximal contiguous frequent sub-sequences, which requires only one scan of the original DNA sequence database. The proposed algorithm has the following characteristics. First, it can accept any value of the minimum support threshold effectively by means of one-time database access and construction of a suffix tree. Second, it can effectively mine the complete set of maximal contiguous frequent patterns without specifying the sequence lengths in advance. Third, the proposed method can produce results only by tree search, without expansion for production of a candidate set. Fourth, from the experimental results, we can see the scalability of our approach. As a result, it can be applied not only to a DNA sequence with a small number of items (dimension) but also amino acid sequences with a large number of items whose sizes can be very large and other multi-dimensional sequence datasets. Our experiments show that MCFS outperforms other existing approaches for mining maximal contiguous sub-sequences. In the future, we intend to extend this work to include gaps and execute it on real biological datasets.