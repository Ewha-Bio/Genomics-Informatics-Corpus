Maximal contiguous frequent suffix tree algorithm
We describe our algorithm, called Maximal Contiguous Frequent Suffix tree algorithm (MCFS), to discover maximal contiguous frequent patterns from DNA sequence datasets. Let us assume for now that the DNA sequence database can be fit into the main memory. The method proceeds as follows: 1) construct four projected databases, namely 〈A〉, 〈T〉, 〈C〉, and 〈G〉, to mine contiguous frequent patterns; 2) insert the suffixes of PDBs into a suffix tree; 3) traverse the whole suffix tree and find the set of frequent contiguous patterns; 4) check the properties of maximality and find the set of maximal contiguous frequent patterns.
In order to efficiently discover frequent sub-sequences, we design a suffix tree structure that stores all the potential sub-sequences and their corresponding supports. A 'potential frequent sub-sequence' is a sub-sequence that has at least two matches with other suffixes inside the PDBs. Each PDB has its own corresponding sub-tree, defined as follows. The root of the tree is the entry point. Each node consists of three fields: item, support, and link to the next node. Item registers which item this node represents. Concatenation of all items along the path from the root to this node represents a sub-sequence. Support registers the support of this suffix sub-sequence from the root node to this node. This means that if we traverse a particular path from top to bottom, then the path from the root to this node represents a sub-sequence, and support of the last node in the path becomes the support of the sub-sequence. The height of the suffix tree is not fixed, because the lengths of the suffixes are variable.
Our proposed algorithm (Fig. 1) proceeds in three steps. The first step scans the original database and constructs four PDBs. While creating PDBs of A, T, C, and G, a register is maintained that checks for duplicate suffixes without sorting the suffixes. If a suffix appears more than once in a PDB, the suffix is inserted into a temporary buffer with support. If a suffix X has n replicas in α-PDBs, for example, we move X to the temporary buffer with support n. This kind of suffix uses very little space and thus can be stored in the memory. Then, we check the suffixes and merge the sub-sequence suffixes with super sequence suffixes according to lemma 1. In this way, the size of physical PDB does not exceed the size of the original database. Inside the PDBs, we do not register the value of sequence ID or offset, because we can directly insert suffixes into the suffix tree.
The second step creates and inserts suffixes into suffix tree. During the insertion process, four situations arise regarding the maximality problem. First, if the inserting sequence is contained by some suffixes in the PDBs, it will match a branch of the suffix tree; then, we delete it from the result set and increase support up to the matching point to stop inserting. Second, if the inserted sequence contains some sequence in the tree, denoted as α, one of its suffixes will match the branch representing α; then, we increase the support of α and delete it from the result set and continue to insert other suffixes. Third, if there exists a suffix totally matching a prefix, say α of a PDB, we continue to find the longest subsequence β following α in S, which matches a root-path in α-subtree. Fourth, if there exists a suffix α that partly matches a prefix, we merge it with the suffix and increase the corresponding support up to the matching point. Otherwise, we just insert it into the suffix tree as a new path. If a suffix has no matches with other suffixes inside a PDB, we just discard the suffix after the traversing.
The third step scans the suffix tree and finds the set of all maximal contiguous frequent patterns. It first finds the set of contiguous frequent sub-sequences and then finds the set of maximal contiguous frequent patterns by checking the properties of maximality.