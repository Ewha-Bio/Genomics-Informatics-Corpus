MCFS algorithm on extra large DNA sequence database
When a DNA sequence database is too large (e.g., 100 GB or more) to fit into the memory, we have to store it on a disk. In this case, different mining techniques are needed, and partitioning is one such technique. Most disk-based partitioning techniques [11-14] find frequent patterns from each partition and check to discover all frequent patterns. This approach, however, has some drawbacks, because frequent patterns may look infrequent due to local support pruning. Suppose our database is partitioned into two parts, D1 and D2. Sequences 10, 20, and 30 are in D1, and 40 and 50 are in D2. Suffix ACT occurs once in D1, so it is not frequent. According to them [12, 13], we have to discard it for local support pruning. Another copy of ACT is in D2 (ID-50), so we discard it from the partition as well. If we consider globally, then ACT will be a frequent pattern, if the minimum support threshold is 2. In this way, many frequent patterns can be lost by partitioning.
In order to deal with this problem, we propose a technique using a combined approach of main memory and disk partitioning. During the first scanning over the database, we partition the original database residing in the disk into smaller parts so that each part can fit into the memory. In this process, the number of partitions should be minimized by reading as many DNA sequences into the memory as possible to constitute one partition. The set of frequent patterns in D is obtained by collecting the discovered patterns after running MCFS on these partitions. The actual maximal contiguous frequent patterns can be identified with only one extra database pass through support counting against all the data sequences in each partition, one at a time. Therefore, we can employ MCFS to mine databases of any size, with any minimum support, in just two passes of database scanning - one for the original database and one for the portioned databases. Firstly, store every frequent pattern into a temporary buffer storage, namely 'frequent file,' with their corresponding support, and infrequent patterns into temporary buffer storage, namely 'output file,' with their corresponding support as well. After that, we collect all the infrequent patterns from each partition and combine them to count the corresponding support of each infrequent pattern.
The main goal of this approach is to process one partition in the memory at a time to avoid multiple scans over D from the secondary storage. Fig. 3 indicates the technique of mining contiguous frequent patterns from disk-based extra large database. In the figure, D1, D2, ..., Dn are the partitions of the original database. Fi is the contiguous frequent patterns, and IFi is the infrequent contiguous patterns from each partition. CFP is contiguous frequent patterns, and MCFPi is maximal contiguous frequent patterns. Fi, IFi, CFP, and MCFPi are all stored on the disk.